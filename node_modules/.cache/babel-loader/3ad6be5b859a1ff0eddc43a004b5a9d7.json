{"ast":null,"code":"var _jsxFileName = \"/home/aronberenyi/Code/ancrypto/src/components/contexts/DataContext.js\";\nimport React, { useState, useEffect } from 'react';\nimport cc from 'cryptocompare';\nimport moment from 'moment';\ncc.setApiKey('6bce00cebd36b06c07f20e0e94c2a0fe1b0211dc0a8a8dc030f6fb8b4117f707');\nconst MAX_FAVOURITES = 10;\nconst TIME_UNITS = 10;\nexport const DataContext = React.createContext();\n\nfunction getCurrFavourite(favourites) {\n  if (!favourites.length) {\n    return null;\n  }\n\n  if (favourites.length) {\n    return favourites[0];\n  }\n\n  let currFavInLocal = getFromLocal('currFavourite');\n\n  if (currFavInLocal) {\n    return currFavInLocal;\n  } else return null;\n}\n\nfunction getFromLocal(item) {\n  let data = JSON.parse(localStorage.getItem('ancrypto'));\n  let answer = data ? data[item] : [];\n  return answer;\n}\n\nconst fetchPrices = async coinsArr => {\n  let returnData = [];\n\n  try {\n    coinsArr.forEach(async coin => {\n      try {\n        let priceData = await cc.priceFull(coin, 'USD'); // Handle if there isn't any price data\n\n        if (!priceData[coin]) {\n          throw 'The API returned an empty object';\n        }\n\n        returnData.push(priceData);\n      } catch (e) {\n        // Handling if there is no data. We use this in ../Dashboard/PriceTile.js\n        returnData.push({\n          [coin]: {\n            noData: true\n          }\n        });\n        console.warn('No price data for: ', coin, e);\n      }\n    });\n  } catch (e) {\n    console.warn('Error during fetching prices :', e);\n  }\n\n  return returnData;\n};\n\nconst fetchCoins = async () => {\n  try {\n    let coins = await cc.coinList();\n    coins = coins.Data;\n    return coins;\n  } catch (e) {\n    console.error('Error during coin fetching: ', e);\n  }\n};\n\nconst historicalPromises = (currFavourite, interval) => {\n  let promises = [];\n\n  for (let i = TIME_UNITS; i > 0; i--) {\n    const date = moment().subtract(i, interval).toDate();\n    promises.push(cc.priceHistorical(currFavourite, ['USD'], date));\n  }\n\n  return Promise.all(promises);\n};\n\nconst fetchHistorical = async (currFavourite, interval) => {\n  const results = await historicalPromises(currFavourite, interval);\n  const historical = [{\n    name: currFavourite,\n    data: results.map((ticker, index) => [moment().subtract(TIME_UNITS - index, interval).valueOf(), ticker.USD])\n  }];\n  return historical;\n};\n\nconst isDay = () => {\n  const hour = new Date().getHours();\n  return hour <= 21 && hour >= 6;\n};\n\nconst sortCoins = cList => {\n  let sortedCoinList = [];\n\n  if (cList) {\n    Object.keys(cList).forEach(key => {\n      let coinObj = cList[key];\n      const order = +coinObj['SortOrder'] - 1;\n      sortedCoinList[order] = coinObj['Symbol'];\n    });\n  }\n\n  return sortedCoinList;\n}; // ===================================================================\n// ==============================DATAPROVIDER=======================================================\n// ===================================================================\n\n\nexport const DataProvider = ({\n  children\n}) => {\n  // ======================STATE========================\n  const [favourites, setFavourites] = useState(getFromLocal('favourites'));\n  const [currFavourite, setCurrFavourite] = useState(getCurrFavourite(favourites));\n  const [coinList, setCoinList] = useState(null);\n  const [sortedCoins, setSortedCoins] = useState([]);\n  const [prices, setPrices] = useState(null);\n  const [historicalData, setHistoricalData] = useState([]);\n  const [historicalInterval, setHistoricalInterval] = useState(\"months\");\n  const [theme, setTheme] = useState(isDay() ? 'light' : 'dark');\n  console.log(isDay()); // =============================================================\n  // =======================EFFECTS===============================\n  // --- STARTUP - init data\n  // (Fetch the list of all the coins)\n\n  useEffect(() => {\n    const init = async () => {\n      try {\n        const coins = await fetchCoins(); // 1\n\n        setCoinList(coins);\n      } catch (e) {\n        console.error('Error during startup coinList fetching: ', e);\n      }\n    };\n\n    init();\n  }, []); // --- Sort coinList based on popularity\n\n  useEffect(() => {\n    setSortedCoins(sortCoins(coinList));\n  }, [coinList]); //--- Fetch prices of all the favourites\n\n  useEffect(() => {\n    const updatePrices = async coinsArr => {\n      if (favourites.length) {\n        let newPrices = await fetchPrices(coinsArr);\n        setPrices(newPrices);\n      }\n    };\n\n    updatePrices(favourites);\n  }, [favourites]); // --- Update historical prices if the selected, or the interval changes\n\n  useEffect(() => {\n    const updateHistoricalPrice = async () => {\n      if (currFavourite) {\n        try {\n          const historical = await fetchHistorical(currFavourite, historicalInterval);\n          setHistoricalData(historical);\n        } catch (e) {\n          console.error('Historical price fetching error: ', e);\n        }\n      }\n    };\n\n    setHistoricalData(null);\n    updateHistoricalPrice();\n  }, [currFavourite, historicalInterval]); // Handle localstorage updates on change\n\n  useEffect(() => {\n    localStorage.setItem('ancrypto', JSON.stringify({\n      favourites,\n      currFavourite\n    }));\n  }, [currFavourite, favourites]); // ----------------------------ADD/REMOVE COIN-------------------------------\n\n  const addCoin = coinKey => {\n    if (!currFavourite) {\n      setCurrFavourite(coinKey);\n    }\n\n    if (favourites.length < MAX_FAVOURITES && !favourites.includes(coinKey)) {\n      setFavourites([...favourites, coinKey]);\n    }\n  };\n\n  const removeCoin = coinKey => {\n    const updatedFavs = favourites.filter(key => key !== coinKey);\n\n    if (favourites.includes(coinKey)) {\n      setCurrFavourite(updatedFavs[0]);\n    }\n\n    setFavourites(updatedFavs);\n  }; // -----------------------------THEME TOGGLER--------------------------\n\n\n  const toggleTheme = () => {\n    setTheme(theme === 'light' ? 'dark' : 'light');\n  };\n\n  return /*#__PURE__*/React.createElement(DataContext.Provider, {\n    value: {\n      theme,\n      toggleTheme,\n      coinList,\n      sortedCoins,\n      historicalData,\n      favourites,\n      setFavourites,\n      historicalInterval,\n      setHistoricalInterval,\n      currFavourite,\n      setCurrFavourite,\n      addCoin,\n      removeCoin,\n      prices\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 204,\n      columnNumber: 3\n    }\n  }, children);\n};","map":{"version":3,"sources":["/home/aronberenyi/Code/ancrypto/src/components/contexts/DataContext.js"],"names":["React","useState","useEffect","cc","moment","setApiKey","MAX_FAVOURITES","TIME_UNITS","DataContext","createContext","getCurrFavourite","favourites","length","currFavInLocal","getFromLocal","item","data","JSON","parse","localStorage","getItem","answer","fetchPrices","coinsArr","returnData","forEach","coin","priceData","priceFull","push","e","noData","console","warn","fetchCoins","coins","coinList","Data","error","historicalPromises","currFavourite","interval","promises","i","date","subtract","toDate","priceHistorical","Promise","all","fetchHistorical","results","historical","name","map","ticker","index","valueOf","USD","isDay","hour","Date","getHours","sortCoins","cList","sortedCoinList","Object","keys","key","coinObj","order","DataProvider","children","setFavourites","setCurrFavourite","setCoinList","sortedCoins","setSortedCoins","prices","setPrices","historicalData","setHistoricalData","historicalInterval","setHistoricalInterval","theme","setTheme","log","init","updatePrices","newPrices","updateHistoricalPrice","setItem","stringify","addCoin","coinKey","includes","removeCoin","updatedFavs","filter","toggleTheme"],"mappings":"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","sourcesContent":["import React, { useState, useEffect } from 'react'\nimport cc from 'cryptocompare'\nimport moment from 'moment'\n\ncc.setApiKey('6bce00cebd36b06c07f20e0e94c2a0fe1b0211dc0a8a8dc030f6fb8b4117f707')\n\nconst MAX_FAVOURITES = 10;\nconst TIME_UNITS = 10; \n\nexport const DataContext = React.createContext();\n\nfunction getCurrFavourite(favourites) {\n  if (!favourites.length) {return null}\n  if (favourites.length) { return favourites[0]}\n  let currFavInLocal = getFromLocal('currFavourite')\n  if (currFavInLocal) {return currFavInLocal}\n  else return null\n}\n\nfunction getFromLocal (item) {\n  let data = JSON.parse(localStorage.getItem('ancrypto'))\n  let answer = data ? data[item] : [];\n  return answer\n}\n\nconst fetchPrices = async (coinsArr) => {\n        \n  let returnData = [];\n  try {\n    coinsArr.forEach(async (coin) => {\n      try {\n          let priceData = await cc.priceFull(coin, 'USD');\n          // Handle if there isn't any price data\n          if (!priceData[coin]) {throw 'The API returned an empty object'}\n          returnData.push(priceData)\n      } catch(e) { \n        // Handling if there is no data. We use this in ../Dashboard/PriceTile.js\n        returnData.push({\n          [coin]: {\n            noData: true\n          }\n        })\n        console.warn('No price data for: ', coin, e) \n      }\n    })\n  } catch(e) {console.warn('Error during fetching prices :', e)}\n  return returnData\n    \n}\n\nconst fetchCoins = async () => {\n  try {\n  let coins = await cc.coinList()\n  coins = coins.Data\n  return coins\n  }\n  catch(e) {console.error('Error during coin fetching: ',e)}\n}\n\nconst historicalPromises = (currFavourite, interval) => {\n  let promises = [];\n  for (let i = TIME_UNITS; i > 0; i--) {\n    const date = moment().subtract(i, interval).toDate()\n    promises.push(\n      cc.priceHistorical(\n        currFavourite, \n        ['USD'], \n        date\n    ))\n  }\n  return Promise.all(promises)\n\n}\n\nconst fetchHistorical = async (currFavourite, interval) => {\n\n  const results = await historicalPromises(currFavourite, interval)\n  const historical = [\n    {\n      name: currFavourite,\n      data: results.map((ticker, index) => [\n        moment().subtract(TIME_UNITS - index, interval).valueOf(),\n        ticker.USD\n      ])\n    }\n  ]\n  return historical\n}\n\n  const isDay = () => {\n    const hour = new Date().getHours();\n    return (hour <= 21 && hour >= 6) \n  }\n\n  const sortCoins = (cList) => {\n\n    let sortedCoinList = []\n    if (cList) {\n      Object.keys(cList).forEach(key => {\n        let coinObj = cList[key]\n        const order = +coinObj['SortOrder'] -1\n        sortedCoinList[order] = coinObj['Symbol']\n      })\n    }\n    return sortedCoinList\n  }\n\n\n  // ===================================================================\n  // ==============================DATAPROVIDER=======================================================\n  // ===================================================================\nexport const DataProvider = ({children}) => {\n\n  // ======================STATE========================\n  const [favourites, setFavourites] = useState(getFromLocal('favourites'));\n  const [currFavourite, setCurrFavourite] = useState(getCurrFavourite(favourites))\n  const [coinList, setCoinList] = useState(null)\n  const [sortedCoins, setSortedCoins] = useState([])\n  const [prices, setPrices] = useState(null);\n  const [historicalData, setHistoricalData] = useState([])\n  const [historicalInterval, setHistoricalInterval] = useState(\"months\")\n  const [theme, setTheme] = useState(isDay() ? 'light' : 'dark' );\n\n  console.log(isDay());\n\n\n\n  // =============================================================\n  // =======================EFFECTS===============================\n\n  // --- STARTUP - init data\n  // (Fetch the list of all the coins)\n  useEffect(() => {\n\n    const init = async () => {\n      try {\n         const coins = await fetchCoins()     // 1\n        setCoinList(coins)\n      } catch(e) {console.error('Error during startup coinList fetching: ', (e))}\n    }    \n    init()\n  }, [])\n\n  // --- Sort coinList based on popularity\n  useEffect(() => {\n    setSortedCoins(sortCoins(coinList))\n  }, [coinList])\n\n  //--- Fetch prices of all the favourites\n  useEffect(() => {\n    const updatePrices = async (coinsArr) => {\n      if (favourites.length) {\n        let newPrices = await fetchPrices(coinsArr)\n        setPrices(newPrices)\n      }}\n    updatePrices(favourites)  \n  }, [favourites]);\n\n  // --- Update historical prices if the selected, or the interval changes\n  useEffect(() => {\n    const updateHistoricalPrice = async () => {\n      if (currFavourite) {\n        try {\n          const historical = await fetchHistorical(currFavourite, historicalInterval)\n          setHistoricalData(historical)\n        } catch(e) {console.error('Historical price fetching error: ', e)}\n      }}\n    setHistoricalData(null)\n    updateHistoricalPrice()\n  }, [currFavourite, historicalInterval])\n\n\n  // Handle localstorage updates on change\n  useEffect(() => {\n    localStorage.setItem('ancrypto', JSON.stringify({\n      favourites,\n      currFavourite\n    }))\n  },[currFavourite, favourites])\n\n\n  // ----------------------------ADD/REMOVE COIN-------------------------------\n  const addCoin = coinKey => {\n    if(!currFavourite) {\n      setCurrFavourite(coinKey)\n    }\n\n    if((favourites.length < MAX_FAVOURITES ) && !favourites.includes(coinKey)) {\n      setFavourites([...favourites, coinKey]);\n    }\n  }\n  const removeCoin = coinKey => {\n    const updatedFavs = favourites.filter(key => key !== coinKey)\n    if( favourites.includes(coinKey) ) {setCurrFavourite(updatedFavs[0])}\n    setFavourites(updatedFavs)\n  }\n  // -----------------------------THEME TOGGLER--------------------------\n  const toggleTheme = () => {\n    setTheme(theme === 'light' ? 'dark' : 'light')\n  }\n\n\n  return (\n  <DataContext.Provider \n    value={\n      {\n        theme,\n        toggleTheme,\n        coinList,\n        sortedCoins,\n        historicalData,\n        favourites,\n        setFavourites,\n        historicalInterval,\n        setHistoricalInterval,\n        currFavourite,\n        setCurrFavourite, \n        addCoin, \n        removeCoin, \n        prices\n      }\n    }\n  >\n    {children}\n  </DataContext.Provider>\n  )\n}"]},"metadata":{},"sourceType":"module"}